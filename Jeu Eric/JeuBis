from install_package import install_package
install_package(["pygame", "pywin32"])
import pygame
import sys
import time
import math
import os
import json
import win32api, win32con

# --- PARAMÈTRES DU JEU ---
MAP_WIDTH = 1600
MAP_HEIGHT = 1200
FPS = 60

PLAYER_SPEED = 400
ANIM_FPS = 8
FRAME_W, FRAME_H = 48, 48
REVEAL_RADIUS = 200
REVEAL_DURATION = 2
COOLDOWN = 10

GRAVITY = 1
JUMP_SPEED = -800

BG_COLOR = (20, 20, 20)
WALL_COLOR = (70, 70, 70)
WHITE = (255, 255, 255)
GREEN = (0, 255, 100)
SAVE_FILE = "save_slots.json"
CTRL_FILE = "controls.json"
SET_FILE = "settings.json"
MAX_SLOTS = 3
#recupperation de la frecuence d'affichage
def get_real_screen_size():
    # Retourne (largeur, hauteur) de l'écran principal
    width = win32api.GetSystemMetrics(0)
    height = win32api.GetSystemMetrics(1)
    return width, height
SCREEN_WIDTH, SCREEN_HEIGHT = get_real_screen_size()
def get_screen_refresh_rate_windows_fixed():
    if sys.platform != "win32":
        print("Cette fonction n'est compatible qu'avec Windows.")
        return 0.0
    
    try:
        # 1. Obtenir les informations du périphérique d'affichage (Moniteur principal : index 0)
        device = win32api.EnumDisplayDevices(None, 0)
        
        # 2. Obtenir les paramètres d'affichage actuels
        #    -> La constante ENUM_CURRENT_SETTINGS est dans win32con
        settings = win32api.EnumDisplaySettings(device.DeviceName, win32con.ENUM_CURRENT_SETTINGS)
        
        # 3. Le taux de rafraîchissement est dans l'attribut DisplayFrequency
        refresh_rate = settings.DisplayFrequency
        
        # win32api retourne un int pour la fréquence
        print(f"Taux de rafraîchissement détecté : {refresh_rate} Hz")
        return float(refresh_rate)
        
    except Exception as e:
        print(f"Erreur API Windows lors de la récupération du taux de rafraîchissement : {e}")
        return 0.0
#sauvegarde
default_controls = {"touches_attaque1": pygame.K_a, "touches_attaque2": pygame.K_z, "touches_attaque3": pygame.K_e,
                     "touches_reveal": pygame.K_r, "touches_droite": pygame.K_RIGHT, "touches_gauche": pygame.K_LEFT}
default_settings = {
    "fps": get_screen_refresh_rate_windows_fixed(),
    "vsync": True,
    "display_mode": ["fullscreen", "borderless", "windowed"],  # windowed | borderless | fullscreen
    "screen_width": SCREEN_WIDTH,
    "screen_height": SCREEN_HEIGHT
}

def load_json(file, default):
    if not os.path.exists(file):
        with open(file, "w") as f: json.dump(default, f, indent=2)
        return default
    with open(file, "r") as f:
        try: return json.load(f)
        except: return default

def save_json(file, data):
    with open(file, "w") as f: json.dump(data, f, indent=2)

def load_saves(): return load_json(SAVE_FILE, [{"exists": False, "progress": 0} for _ in range(MAX_SLOTS)])
def save_saves(saves): save_json(SAVE_FILE, saves)
def load_controls(): return load_json(CTRL_FILE, default_controls)
def save_controls(ctrls): save_json(CTRL_FILE, ctrls)
def load_settings(): return load_json(SET_FILE, default_settings)
def save_settings(s): save_json(SET_FILE, s)

controls = load_controls()
settings = load_settings()
# --- INITIALISATION ---
pygame.init()
pygame.display.set_caption("Human Explorer")
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
font = pygame.font.SysFont("cambria", 25)
clock = pygame.time.Clock()

# --- FONCTIONS UTILES ---
def load_frames_from_sheet(filename, frame_w, frame_h):
    base_path = os.path.dirname(__file__)
    sheet_path = os.path.join(base_path, filename)
    if not os.path.exists(sheet_path):
        raise FileNotFoundError(f"Sprite sheet non trouvé : {sheet_path}")
    sheet = pygame.image.load(sheet_path).convert_alpha()
    sheet_rect = sheet.get_rect()
    frames = []
    for i in range(sheet_rect.w // frame_w):
        frame = sheet.subsurface((i * frame_w, 0, frame_w, frame_h))
        frames.append(frame)
    return frames

def safe_load_frames(filename, frame_w, frame_h):
    """Crée des sprites factices si le fichier est absent."""
    try:
        return load_frames_from_sheet(filename, frame_w, frame_h)
    except Exception as e:
        surf = pygame.Surface((frame_w, frame_h), pygame.SRCALPHA)
        return [surf] * 4

def draw_reveal_wave(surface, player, walls, elapsed, reveal_start, camera_x, camera_y):
    radius = int((elapsed / REVEAL_DURATION) * REVEAL_RADIUS)
    overlay = pygame.Surface((settings["screen_width"], settings["screen_height"]), pygame.SRCALPHA)
    overlay.fill((0, 0, 0, 200))
    cx, cy = player.rect.centerx - camera_x, player.rect.centery - camera_y
    for angle in range(0, 360, 3):
        for r in range(radius):
            x = int(cx + math.cos(math.radians(angle)) * r)
            y = int(cy + math.sin(math.radians(angle)) * r)
            hit = False
            for wall in walls:
                if wall.collidepoint(player.rect.centerx + math.cos(math.radians(angle)) * r,
                                     player.rect.centery + math.sin(math.radians(angle)) * r):
                    hit = True
                    break
            if hit:
                break
            if 0 <= x < settings["screen_width"] and 0 <= y < settings["screen_height"]:
                overlay.set_at((x, y), (0, 0, 0, 0))
    surface.blit(overlay, (0, 0))

# ================= FENÊTRE / VIDÉO =================
def apply_display_settings():
    global screen, clock
    flags = 0
    if settings["display_mode"] == "borderless":
        flags = pygame.NOFRAME
        screen = pygame.display.set_mode((settings["screen_width"], settings["screen_height"]), flags, vsync=settings["vsync"])
    elif settings["display_mode"] == "fullscreen":
        flags = pygame.FULLSCREEN
        screen = pygame.display.set_mode((settings["screen_width"], settings["screen_height"]), flags, vsync=settings["vsync"])
    else:
        screen = pygame.display.set_mode((settings["screen_width"], settings["screen_height"]), vsync=settings["vsync"])
    clock = pygame.time.Clock()
    pygame.display.set_caption("EchoVerse — Premier aperçu")

apply_display_settings()

# --- CLASSE JOUEUR ---
class AnimatedPlayer(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        # Charge toutes les animations
        self.animations = {
            "run": safe_load_frames("RUN.png", 48, 48,),
            "idle": safe_load_frames("IDLE.png", 48, 48),
            "jump": safe_load_frames("JUMP.png", 48, 48),
            "attack1": safe_load_frames("ATTACK 1.png", 64, 48),
            "attack2": safe_load_frames("ATTACK 2.png", 80, 48),
            "attack3": safe_load_frames("ATTACK 3.png", 80, 64),
        }
        # Flip gauche
        for key in list(self.animations.keys()):
            self.animations[key + "_left"] = [pygame.transform.flip(f, True, False) for f in self.animations[key]]

        self.state = "run"
        self.direction = "right"
        self.frame_index = 0
        self.image = self.animations["run"][0]
        self.rect = self.image.get_rect(midbottom=(x, y))
        self.speed = PLAYER_SPEED
        self.last_update = time.time()
        self.last_reveal = 0
        self.cooldown = COOLDOWN

        # Gravité
        self.vy = 0
        self.on_ground = False

        # Attaque
        self.attacking = False
        self.attack_start = 0
        self.attack_duration = 0.5
        self.attack_type = None

    def set_image(self, new_image):
        bottom_center = self.rect.midbottom
        self.image = new_image
        self.rect = self.image.get_rect()
        self.rect.midbottom = bottom_center

    def handle_input(self, walls, dt):
        keys = pygame.key.get_pressed()
        dx, dy = 0, 0

        if not self.attacking:
            if keys[pygame.K_DOWN]:
                dy = self.speed*dt
            if keys[pygame.K_LEFT]:
                dx = -self.speed*dt
                self.direction = "left"
            elif keys[controls["touches_droite"]]:
                dx = (self.speed*dt)
                self.direction = "right"

            # Saut
            if keys[pygame.K_SPACE] and self.on_ground:
                self.vy = JUMP_SPEED*dt

            if keys[pygame.K_UP] and self.on_ground:
                self.vy = JUMP_SPEED*dt

            # Attaques
            if keys[controls["touches_attaque1"]]:
                self.start_attack("attack1")
            elif keys[controls["touches_attaque2"]]:
                self.start_attack("attack2")
            elif keys[controls["touches_attaque3"]]:
                self.start_attack("attack3")

            # Reveal avec la touche R
            if keys[controls["touches_reveal"]] and self.can_reveal():
                self.reveal()

        self.move_and_collide(dx, dy, walls)

    def start_attack(self, attack_type):
        self.attacking = True
        self.attack_start = time.time()
        self.attack_type = attack_type
        self.frame_index = 0
        self.state = attack_type

    def move_and_collide(self, dx, dy, walls):
        self.rect.x += dx
        for wall in walls:
            if self.rect.colliderect(wall):
                if dx > 0:
                    self.rect.right = wall.left
                elif dx < 0:
                    self.rect.left = wall.right

        self.rect.y += dy
        for wall in walls:
            if self.rect.colliderect(wall):
                if dy > 0:
                    self.rect.bottom = wall.top
                elif dy < 0:
                    self.rect.top = wall.bottom

        self.rect.left = max(0, self.rect.left)
        self.rect.top = max(0, self.rect.top)
        self.rect.right = min(MAP_WIDTH, self.rect.right)
        self.rect.bottom = min(MAP_HEIGHT, self.rect.bottom)

    def apply_gravity(self, walls):
        self.vy += GRAVITY
        self.rect.y += self.vy
        self.on_ground = False
        for wall in walls:
            if self.rect.colliderect(wall):
                if self.vy > 0:  # tombe sur le sol
                    self.rect.bottom = wall.top
                    self.vy = 0
                    self.on_ground = True
                elif self.vy < 0:  # touche plafond
                    self.rect.top = wall.bottom
                    self.vy = 0

    def update_animation(self):
        now = time.time()

        # Si en attaque
        if self.attacking:
            # Vérifie si la durée est passée
            if now - self.attack_start >= self.attack_duration:
                self.attacking = False
                self.state = "run"
                self.frame_index = 0  # reset
            anim_key = self.state  # attaque en cours
        # Si en l'air
        elif not self.on_ground:
            anim_key = "jump"
        # Sinon idle / run
        else:
            keys = pygame.key.get_pressed()
            moving = any([keys[pygame.K_LEFT], keys[pygame.K_RIGHT]])
            anim_key = "run" if moving else "idle"

        # Version gauche
        anim_key += "_left" if self.direction == "left" else ""
        frames = self.animations[anim_key]

        # Mise à jour des frames
        if now - self.last_update > 0.1:
            self.frame_index = (self.frame_index + 1) % len(frames)
            self.set_image(frames[self.frame_index])
            self.last_update = now

    def can_reveal(self):
        return (time.time() - self.last_reveal) >= self.cooldown

    def reveal(self):
        self.last_reveal = time.time()

    def draw(self, surface, camera_x=0, camera_y=0):
        surface.blit(self.image, (self.rect.x - camera_x, self.rect.y - camera_y))

# --- CLASSE BOUTON ---
class Button():
    def __init__(self, text, y, action):
        self.text = text
        self.action = action
        self.image = pygame.Surface((250, 70))
        self.image.fill((50, 50, 50))
        self.rect = self.image.get_rect(center=(settings["screen_width"] // 2, y))
        self.font = pygame.font.SysFont("cambria", 32)

    def draw(self, surface):
        mouse = pygame.mouse.get_pos()
        color = GREEN if self.rect.collidepoint(mouse) else WHITE
        text = self.font.render(self.text, True, color)
        text_rect = text.get_rect(center=self.rect.center)
        surface.blit(self.image, self.rect)
        surface.blit(text, text_rect)

    def click(self):
        if self.rect.collidepoint(pygame.mouse.get_pos()):
            self.action()

# --- MAP / MURS ---
walls = [
    pygame.Rect(30, 30, 20, 1120), # Mur de gauche
    pygame.Rect(30, 1150, 1540, 20), # Mur du bas
    pygame.Rect(1550, 30, 20, 1140), # Mur de droite
    pygame.Rect(50, 30, 1520, 20), # Mur du haut
    pygame.Rect(500, 600, 600, 600), # Plateforme 1 
    pygame.Rect(200, 525, 300, 20), # Plateforme 2
    pygame.Rect(750, 400, 400, 30), # Plateforme 3
    pygame.Rect(600, 450, 20, 20), # Box 1
]

# --- BOUCLE DU JEU ---
def run_game():
    player = AnimatedPlayer(MAP_WIDTH // 2, MAP_HEIGHT // 2)
    revealing = False
    reveal_start = 0
    running=True
    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT or (event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE):
                pygame.quit()
                sys.exit()
            if event.type == pygame.KEYDOWN and event.key == pygame.K_r and player.can_reveal():
                revealing = True
                reveal_start = time.time()
                player.reveal()

        player.handle_input(walls, dt=clock.get_time()/1000)
        player.apply_gravity(walls)
        player.update_animation()

        camera_x = player.rect.centerx - settings["screen_width"] // 2
        camera_y = player.rect.bottom - settings["screen_height"] // 2
        camera_x = max(0, min(MAP_WIDTH - settings["screen_width"], camera_x))
        camera_y = max(0, min(MAP_HEIGHT - settings["screen_height"], camera_y))

        screen.fill(BG_COLOR)

        for wall in walls:
            rect = pygame.Rect(wall.x - camera_x, wall.y - camera_y, wall.width, wall.height)
            pygame.draw.rect(screen, WALL_COLOR, rect)

        if revealing:
            elapsed = time.time() - reveal_start
            if elapsed > REVEAL_DURATION:
                revealing = False
            else:
                draw_reveal_wave(screen, player, walls, elapsed, reveal_start, camera_x, camera_y)

        player.draw(screen, camera_x, camera_y)

        remaining = max(0, int(COOLDOWN - (time.time() - player.last_reveal)))
        text = font.render(f"Reveal dans : {remaining}s", True, WHITE)
        screen.blit(text, (10, 10))

        pygame.display.flip()
        clock.tick(settings["fps"])

#Video settings
def video_settings():
    pass
    
# --- PARAMÈTRES ---   
def run_settings():
    screen_settings_button = Button("SCREEN", 300, video_settings)
    controls_settings_button = Button("CONTROLS", 400, lambda: print("→ Contrôles non implémentés"))
    exit_settings_button = Button("BACK", 500, run_menu)
    buttons = [screen_settings_button, controls_settings_button, exit_settings_button]
    while True:
        screen.fill((25, 25, 25))
        title_font = pygame.font.SysFont("cambria", 50, True)
        title_text = title_font.render("ECHO", True, WHITE)
        screen.blit(title_text, (settings["screen_width"] // 2 - title_text.get_width() // 2, 150))
        for button in buttons:
            button.draw(screen)

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            if event.type == pygame.MOUSEBUTTONDOWN:
                for button in buttons:
                    button.click()

        pygame.display.flip()  
        clock.tick(60)
# --- MENU ---
def run_menu():
    play_button = Button("PLAY", 300, run_game)
    settings_button = Button("SETTINGS", 400, run_settings)
    quit_button = Button("QUIT", 500, lambda: sys.exit())
    buttons = [play_button, settings_button, quit_button]

    while True:
        screen.fill((25, 25, 25))
        title_font = pygame.font.SysFont("cambria", 50, True)
        title_text = title_font.render("HUMAN EXPLORER", True, WHITE)
        screen.blit(title_text, (SCREEN_WIDTH // 2 - title_text.get_width() // 2, 150))

        for button in buttons:
            button.draw(screen)

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            if event.type == pygame.MOUSEBUTTONDOWN:
                for button in buttons:
                    button.click()

        pygame.display.flip()
        clock.tick(60)

# --- LANCEMENT ---
if __name__ == "__main__":
    run_menu()