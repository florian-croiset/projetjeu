import pygame
import sys
import time
import math
import os

# --- PARAMÈTRES DU JEU ---
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
MAP_WIDTH = 1600
MAP_HEIGHT = 1200
FPS = 60

PLAYER_SPEED = 5
ANIM_FPS = 8
FRAME_W, FRAME_H = 48, 48
REVEAL_RADIUS = 200
REVEAL_DURATION = 2
COOLDOWN = 10

GRAVITY = 0.5
JUMP_SPEED = -10

BG_COLOR = (20, 20, 20)
WALL_COLOR = (70, 70, 70)
WHITE = (255, 255, 255)
GREEN = (0, 255, 100)

# --- INITIALISATION ---
pygame.init()
pygame.display.set_caption("Human Explorer")
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
font = pygame.font.SysFont("cambria", 25)
clock = pygame.time.Clock()

# --- FONCTIONS UTILES ---
def load_frames_from_sheet(filename, frame_w, frame_h):
    base_path = os.path.dirname(__file__)
    sheet_path = os.path.join(base_path, filename)
    if not os.path.exists(sheet_path):
        raise FileNotFoundError(f"Sprite sheet non trouvé : {sheet_path}")
    sheet = pygame.image.load(sheet_path).convert_alpha()
    sheet_rect = sheet.get_rect()
    frames = []
    for i in range(sheet_rect.w // frame_w):
        frame = sheet.subsurface((i * frame_w, 0, frame_w, frame_h))
        frames.append(frame)
    return frames

def safe_load_frames(filename, frame_w, frame_h):
    """Crée des sprites factices si le fichier est absent."""
    try:
        return load_frames_from_sheet(filename, frame_w, frame_h)
    except Exception as e:
        surf = pygame.Surface((frame_w, frame_h), pygame.SRCALPHA)
        return [surf] * 4

def draw_reveal_wave(surface, player, walls, elapsed, reveal_start, camera_x, camera_y):
    radius = int((elapsed / REVEAL_DURATION) * REVEAL_RADIUS)
    overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
    overlay.fill((0, 0, 0, 200))
    cx, cy = player.rect.centerx - camera_x, player.rect.centery - camera_y
    for angle in range(0, 360, 3):
        for r in range(radius):
            x = int(cx + math.cos(math.radians(angle)) * r)
            y = int(cy + math.sin(math.radians(angle)) * r)
            hit = False
            for wall in walls:
                if wall.collidepoint(player.rect.centerx + math.cos(math.radians(angle)) * r,
                                     player.rect.centery + math.sin(math.radians(angle)) * r):
                    hit = True
                    break
            if hit:
                break
            if 0 <= x < SCREEN_WIDTH and 0 <= y < SCREEN_HEIGHT:
                overlay.set_at((x, y), (0, 0, 0, 0))
    surface.blit(overlay, (0, 0))

# --- CLASSE JOUEUR ---
class AnimatedPlayer(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        # Charge toutes les animations
        self.animations = {
            "run": safe_load_frames("RUN.png", 48, 48,),
            "idle": safe_load_frames("IDLE.png", 48, 48),
            "jump": safe_load_frames("JUMP.png", 48, 48),
            "attack1": safe_load_frames("ATTACK 1.png", 64, 48),
            "attack2": safe_load_frames("ATTACK 2.png", 80, 48),
            "attack3": safe_load_frames("ATTACK 3.png", 80, 64),
        }
        # Flip gauche
        for key in list(self.animations.keys()):
            self.animations[key + "_left"] = [pygame.transform.flip(f, True, False) for f in self.animations[key]]

        self.state = "run"
        self.direction = "right"
        self.frame_index = 0
        self.image = self.animations["run"][0]
        self.rect = self.image.get_rect(midbottom=(x, y))
        self.speed = PLAYER_SPEED
        self.last_update = time.time()
        self.last_reveal = 0
        self.cooldown = COOLDOWN

        # Gravité
        self.vy = 0
        self.on_ground = False

        # Attaque
        self.attacking = False
        self.attack_start = 0
        self.attack_duration = 0.5
        self.attack_type = None

    def set_image(self, new_image):
        bottom_center = self.rect.midbottom
        self.image = new_image
        self.rect = self.image.get_rect()
        self.rect.midbottom = bottom_center

    def handle_input(self, walls):
        keys = pygame.key.get_pressed()
        dx, dy = 0, 0

        if not self.attacking:
            if keys[pygame.K_UP]:
                dy = -self.speed
            elif keys[pygame.K_DOWN]:
                dy = self.speed
            if keys[pygame.K_LEFT]:
                dx = -self.speed
                self.direction = "left"
            elif keys[pygame.K_RIGHT]:
                dx = self.speed
                self.direction = "right"

            # Saut
            if keys[pygame.K_SPACE] and self.on_ground:
                self.vy = JUMP_SPEED

            # Attaques
            if keys[pygame.K_a]:
                self.start_attack("attack1")
            elif keys[pygame.K_z]:
                self.start_attack("attack2")
            elif keys[pygame.K_e]:
                self.start_attack("attack3")

            # Reveal avec la touche R
            if keys[pygame.K_r] and self.can_reveal():
                self.reveal()

        self.move_and_collide(dx, dy, walls)

    def start_attack(self, attack_type):
        self.attacking = True
        self.attack_start = time.time()
        self.attack_type = attack_type
        self.frame_index = 0
        self.state = attack_type

    def move_and_collide(self, dx, dy, walls):
        self.rect.x += dx
        for wall in walls:
            if self.rect.colliderect(wall):
                if dx > 0:
                    self.rect.right = wall.left
                elif dx < 0:
                    self.rect.left = wall.right

        self.rect.y += dy
        for wall in walls:
            if self.rect.colliderect(wall):
                if dy > 0:
                    self.rect.bottom = wall.top
                elif dy < 0:
                    self.rect.top = wall.bottom

        self.rect.left = max(0, self.rect.left)
        self.rect.top = max(0, self.rect.top)
        self.rect.right = min(MAP_WIDTH, self.rect.right)
        self.rect.bottom = min(MAP_HEIGHT, self.rect.bottom)

    def apply_gravity(self, walls):
        self.vy += GRAVITY
        self.rect.y += self.vy
        self.on_ground = False
        for wall in walls:
            if self.rect.colliderect(wall):
                if self.vy > 0:  # tombe sur le sol
                    self.rect.bottom = wall.top
                    self.vy = 0
                    self.on_ground = True
                elif self.vy < 0:  # touche plafond
                    self.rect.top = wall.bottom
                    self.vy = 0

    def update_animation(self):
        now = time.time()

        # Si en attaque
        if self.attacking:
            # Vérifie si la durée est passée
            if now - self.attack_start >= self.attack_duration:
                self.attacking = False
                self.state = "run"
                self.frame_index = 0  # reset
            anim_key = self.state  # attaque en cours
        # Si en l'air
        elif not self.on_ground:
            anim_key = "jump"
        # Sinon idle / run
        else:
            keys = pygame.key.get_pressed()
            moving = any([keys[pygame.K_UP], keys[pygame.K_DOWN], keys[pygame.K_LEFT], keys[pygame.K_RIGHT]])
            anim_key = "run" if moving else "idle"

        # Version gauche
        anim_key += "_left" if self.direction == "left" else ""
        frames = self.animations[anim_key]

        # Mise à jour des frames
        if now - self.last_update > 0.1:
            self.frame_index = (self.frame_index + 1) % len(frames)
            self.set_image(frames[self.frame_index])
            self.last_update = now

    def can_reveal(self):
        return (time.time() - self.last_reveal) >= self.cooldown

    def reveal(self):
        self.last_reveal = time.time()

    def draw(self, surface, camera_x=0, camera_y=0):
        surface.blit(self.image, (self.rect.x - camera_x, self.rect.y - camera_y))

# --- CLASSE BOUTON ---
class Button():
    def __init__(self, text, y, action):
        self.text = text
        self.action = action
        self.image = pygame.Surface((250, 70))
        self.image.fill((50, 50, 50))
        self.rect = self.image.get_rect(center=(SCREEN_WIDTH // 2, y))
        self.font = pygame.font.SysFont("cambria", 32)

    def draw(self, surface):
        mouse = pygame.mouse.get_pos()
        color = GREEN if self.rect.collidepoint(mouse) else WHITE
        text = self.font.render(self.text, True, color)
        text_rect = text.get_rect(center=self.rect.center)
        surface.blit(self.image, self.rect)
        surface.blit(text, text_rect)

    def click(self):
        if self.rect.collidepoint(pygame.mouse.get_pos()):
            self.action()

# --- MAP / MURS ---
walls = [
    pygame.Rect(300, 200, 300, 20),
    pygame.Rect(700, 100, 20, 300),
    pygame.Rect(500, 500, 400, 20),
    pygame.Rect(1000, 400, 20, 300),
    pygame.Rect(800, 800, 200, 20),
]

# --- BOUCLE DU JEU ---
def run_game():
    player = AnimatedPlayer(MAP_WIDTH // 2, MAP_HEIGHT // 2)
    revealing = False
    reveal_start = 0
    running = True

    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            if event.type == pygame.KEYDOWN and event.key == pygame.K_r and player.can_reveal():
                revealing = True
                reveal_start = time.time()
                player.reveal()

        player.handle_input(walls)
        player.apply_gravity(walls)
        player.update_animation()

        camera_x = player.rect.centerx - SCREEN_WIDTH // 2
        camera_y = player.rect.bottom - SCREEN_HEIGHT // 2
        camera_x = max(0, min(MAP_WIDTH - SCREEN_WIDTH, camera_x))
        camera_y = max(0, min(MAP_HEIGHT - SCREEN_HEIGHT, camera_y))

        screen.fill(BG_COLOR)

        for wall in walls:
            rect = pygame.Rect(wall.x - camera_x, wall.y - camera_y, wall.width, wall.height)
            pygame.draw.rect(screen, WALL_COLOR, rect)

        if revealing:
            elapsed = time.time() - reveal_start
            if elapsed > REVEAL_DURATION:
                revealing = False
            else:
                draw_reveal_wave(screen, player, walls, elapsed, reveal_start, camera_x, camera_y)

        player.draw(screen, camera_x, camera_y)

        remaining = max(0, int(COOLDOWN - (time.time() - player.last_reveal)))
        text = font.render(f"Reveal dans : {remaining}s", True, WHITE)
        screen.blit(text, (10, 10))

        pygame.display.flip()
        clock.tick(FPS)

# --- MENU ---
def run_menu():
    play_button = Button("PLAY", 300, run_game)
    settings_button = Button("SETTINGS", 400, lambda: print("→ Paramètres non implémentés"))
    quit_button = Button("QUIT", 500, lambda: sys.exit())
    buttons = [play_button, settings_button, quit_button]

    while True:
        screen.fill((25, 25, 25))
        title_font = pygame.font.SysFont("cambria", 50, True)
        title_text = title_font.render("HUMAN EXPLORER", True, WHITE)
        screen.blit(title_text, (SCREEN_WIDTH // 2 - title_text.get_width() // 2, 150))

        for button in buttons:
            button.draw(screen)

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            if event.type == pygame.MOUSEBUTTONDOWN:
                for button in buttons:
                    button.click()

        pygame.display.flip()
        clock.tick(60)

# --- LANCEMENT ---
if __name__ == "__main__":
    run_menu()